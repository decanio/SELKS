#Parser generated by Jason Smith

#Currently parses the following logs;
#communication.log
#conn.log
#conn-summary.log
#dhcp.log
#dns.log
#dpd.log
#files.log
#http.log
#packet_filter.log
#reporter.log
#software.log
#ssl.log
#weird.log
#notice.log

input {

#Production Logs#############################
  file {
    type => "BRO_httplog"
    path => "/usr/local/bro/logs/current/http.log"
  }
  file {
    type => "BRO_dpdlog"
    path => "/usr/local/bro/logs/current/dpd.log"
  }
  file {
    type => "BRO_connlog"
    path => "/usr/local/bro/logs/current/conn.log"
  }
  file {
    type => "BRO_weirdlog"
    path => "/usr/local/bro/logs/current/weird.log"
  }
  file {
    type => "BRO_appstatslog"
    path => "/usr/local/bro/logs/current/appstats.log"
  }
  file {
    type => "BRO_communicationlog"
    path => "/usr/local/bro/logs/current/communication.log"
  }
  file {
    type => "BRO_dhcplog"
    path => "/usr/local/bro/logs/current/dhcp.log"
  }
  file {
    type => "BRO_fileslog"
    path => "/usr/local/bro/logs/current/files.log"
  }
  file {
    type => "BRO_SSLlog"
    path => "/usr/local/bro/logs/current/ssl.log"
  }
  file {
    type => "BRO_noticelog"
    path => "/usr/local/bro/logs/current/notice.log"
  }
  file {
    type => "BRO_softwarelog"
    path => "/usr/local/bro/logs/current/software.log"
  }
  file {
    type => "BRO_reporterlog"
    path => "/usr/local/bro/logs/current/reporter.log"
  }
  file {
    type => "BRO_packetfilterlog"
    path => "/usr/local/bro/logs/current/packet_filter.log"
  }
  file {
    type => "BRO_dnslog"
    path => "/usr/local/bro/logs/current/dns.log"
  }

#Test Logs#############################################
#  file {
#    type => "BRO_httplogTEST"
#    path => "/home/idsusr/brotest/http.log"
#  }
#  file {
#    type => "BRO_noticelogTEST"
#    path => "/home/idsusr/brotest/notice.log"
#  }
#######################################################
}

filter {

if [message] =~ /^#/ {
  drop {  }
} else {  

# BRO_httplog ######################
  if [type] == "BRO_httplog" {
      grok { 
        match => [ "message", "(?<bro.ts>(.*?))\t(?<bro.uid>(.*?))\t(?<bro.id.orig_h>(.*?))\t(?<bro.id.orig_p>(.*?))\t(?<bro.id.resp_h>(.*?))\t(?<bro.id.resp_p>(.*?))\t(?<bro.trans_depth>(.*?))\t(?<bro.method>(.*?))\t(?<bro.host>(.*?))\t(?<uri>(.*?))\t(?<bro.referrer>(.*?))\t(?<bro.user_agent>(.*?))\t(?<bro.request_body_len>(.*?))\t(?<bro.response_body_len>(.*?))\t(?<bro.status_code>(.*?))\t(?<bro.status_msg>(.*?))\t(?<bro.info_code>(.*?))\t(?<bro.info_msg>(.*?))\t(?<bro.filename>(.*?))\t(?<bro.tags>(.*?))\t(?<bro.username>(.*?))\t(?<bro.password>(.*?))\t(?<bro.proxied>(.*?))\t(?<bro.orig_fuids>(.*?))\t(?<bro.orig_mime_types>(.*?))\t(?<bro.resp_fuids>(.*?))\t(?<bro.resp_mime_types>(.*))" ]
      }
  }

# BRO_dpdlog ######################
  if [type] == "BRO_dpdlog" {
      grok { 
        match => [ "message", "(?<bro.ts>(.*?))\t(?<bro.uid>(.*?))\t(?<bro.id.orig_h>(.*?))\t(?<bro.id.orig_p>(.*?))\t(?<bro.id.resp_h>(.*?))\t(?<bro.id.resp_p>(.*?))\t(?<bro.proto>(.*?))\t(?<bro.analyzer>(.*?))\t(?<bro.failure_reason>(.*))" ]
      }
  }

# BRO_connlog ######################
  if [type] == "BRO_connlog" {
    grok { 
      match => [ "message", "(?<bro.ts>(.*?))\t(?<bro.uid>(.*?))\t(?<bro.id.orig_h>(.*?))\t(?<bro.id.orig_p>(.*?))\t(?<bro.id.resp_h>(.*?))\t(?<bro.id.resp_p>(.*?))\t(?<bro.proto>(.*?))\t(?<bro.service>(.*?))\t(?<bro.duration>(.*?))\t(?<bro.orig_bytes>(.*?))\t(?<bro.resp_bytes>(.*?))\t(?<bro.conn_state>(.*?))\t(?<bro.local_orig>(.*?))\t(?<bro.missed_bytes>(.*?))\t(?<bro.history>(.*?))\t(?<bro.orig_pkts>(.*?))\t(?<bro.orig_ip_bytes>(.*?))\t(?<bro.resp_pkts>(.*?))\t(?<bro.resp_ip_bytes>(.*?))\t(?<bro.tunnel_parents>(.*))" ]
    }
  }

# BRO_weirdlog ######################
  if [type] == "BRO_weirdlog" {
    grok { 
      match => [ "message", "(?<bro.ts>(.*?))\t(?<bro.uid>(.*?))\t(?<bro.id.orig_h>(.*?))\t(?<bro.id.orig_p>(.*?))\t(?<bro.id.resp_h>(.*?))\t(?<bro.id.resp_p>(.*?))\t(?<bro.name>(.*?))\t(?<bro.addl>(.*?))\t(?<bro.notice>(.*?))\t(?<bro.peer>(.*))" ]
    }
  }

# BRO_appstatslog ######################
  if [type] == "BRO_appstatslog" {
    grok { 
      match => [ "message", "(?<bro.ts>(.*?))\t(?<bro.ts_delta>(.*?))\t(?<bro.app>(.*?))\t(?<bro.uniq_hosts>(.*?))\t(?<bro.hits>(.*?))\t(?<bro.bytes>(.*))" ]
    }
  }
# BRO_communicationlog ######################
  if [type] == "BRO_communicationlog" {
    grok { 
      match => [ "message", "(?<bro.ts>(.*?))\t(?<bro.peer>(.*?))\t(?<bro.src_name>(.*?))\t(?<bro.connected_peer_desc>(.*?))\t(?<bro.connected_peer_addr>(.*?))\t(?<bro.connected_peer_port>(.*?))\t(?<bro.level>(.*?))\t(?<bro.message>(.*))" ]
    }
  }
# BRO_dhcplog ######################
  if [type] == "BRO_dhcplog" {
    grok { 
      match => [ "message", "(?<bro.ts>(.*?))\t(?<bro.uid>(.*?))\t(?<bro.id.orig_h>(.*?))\t(?<bro.id.orig_p>(.*?))\t(?<bro.id.resp_h>(.*?))\t(?<bro.id.resp_p>(.*?))\t(?<bro.mac>(.*?))\t(?<bro.assigned_ip>(.*?))\t(?<bro.lease_time>(.*?))\t(?<bro.trans_id>(.*))" ]
    }
  }

# BRO_fileslog ######################
  if [type] == "BRO_fileslog" {
    grok { 
      match => [ "message", "(?<bro.ts>(.*?))\t(?<bro.fuid>(.*?))\t(?<bro.tx_hosts>(.*?))\t(?<bro.rx_hosts>(.*?))\t(?<bro.conn_uids>(.*?))\t(?<bro.source>(.*?))\t(?<bro.depth>(.*?))\t(?<bro.analyzers>(.*?))\t(?<bro.mime_type>(.*?))\t(?<bro.filename>(.*?))\t(?<bro.duration>(.*?))\t(?<bro.local_orig>(.*?))\t(?<bro.is_orig>(.*?))\t(?<bro.seen_bytes>(.*?))\t(?<bro.total_bytes>(.*?))\t(?<bro.missing_bytes>(.*?))\t(?<bro.overflow_bytes>(.*?))\t(?<bro.timedout>(.*?))\t(?<bro.parent_fuid>(.*?))\t(?<bro.md5>(.*?))\t(?<bro.sha1>(.*?))\t(?<bro.sha256>(.*?))\t(?<bro.extracted>(.*))" ]
    }
  }

# BRO_SSLlog ######################
  if [type] == "BRO_SSLlog" {
    grok { 
      match => [ "message", "(?<bro.ts>(.*?))\t(?<bro.uid>(.*?))\t(?<bro.id.orig_h>(.*?))\t(?<bro.id.orig_p>(.*?))\t(?<bro.id.resp_h>(.*?))\t(?<bro.id.resp_p>(.*?))\t(?<bro.version>(.*?))\t(?<bro.cipher>(.*?))\t(?<bro.server_name>(.*?))\t(?<bro.session_id>(.*?))\t(?<bro.subject>(.*?))\t(?<bro.issuer_subject>(.*?))\t(?<bro.not_valid_before>(.*?))\t(?<bro.not_valid_after>(.*?))\t(?<bro.last_alert>(.*?))\t(?<bro.client_subject>(.*?))\t(?<bro.client_issuer_subject>(.*?))\t(?<bro.cert_hash>(.*?))\t(?<bro.validation_status>(.*))" ]
    }
  }

# BRO_noticelog ######################
  if [type] == "BRO_noticelog" {
    grok { 
      match => [ "message", "(?<bro.ts>(.*?))\t(?<bro.uid>(.*?))\t(?<bro.id.orig_h>(.*?))\t(?<bro.id.orig_p>(.*?))\t(?<bro.id.resp_h>(.*?))\t(?<bro.id.resp_p>(.*?))\t(?<bro.fuid>(.*?))\t(?<bro.file_mime_type>(.*?))\t(?<bro.file_desc>(.*?))\t(?<bro.proto>(.*?))\t(?<bro.note>(.*?))\t(?<bro.msg>(.*?))\t(?<bro.sub>(.*?))\t(?<bro.src>(.*?))\t(?<bro.dst>(.*?))\t(?<bro.p>(.*?))\t(?<bro.n>(.*?))\t(?<bro.peer_descr>(.*?))\t(?<bro.actions>(.*?))\t(?<bro.suppress_for>(.*?))\t(?<bro.dropped>(.*?))\t(?<bro.remote_location.country_code>(.*?))\t(?<bro.remote_location.region>(.*?))\t(?<bro.remote_location.city>(.*?))\t(?<bro.remote_location.latitude>(.*?))\t(?<bro.remote_location.longitude>(.*))" ]
    }
  }

# BRO_softwarelog ######################
  if [type] == "BRO_softwarelog" {
    grok { 
      match => [ "message", "(?<bro.ts>(.*?))\t(?<bro.host>(.*?))\t(?<bro.host_p>(.*?))\t(?<bro.software_type>(.*?))\t(?<bro.name>(.*?))\t(?<bro.version.major>(.*?))\t(?<bro.version.minor>(.*?))\t(?<bro.version.minor2>(.*?))\t(?<bro.version.minor3>(.*?))\t(?<bro.version.addl>(.*?))\t(?<bro.unparsed_version>(.*))" ]
    }
  }

# BRO_reporterlog ######################
  if [type] == "BRO_reporterlog" {
    grok { 
      match => [ "message", "(?<bro.ts>(.*?))\t(?<bro.level>(.*?))\t(?<bro.message>(.*?))\t(?<bro.location>(.*))" ]
    }
  }

# BRO_packetfilterlog ######################
  if [type] == "BRO_packetfilterlog" {
    grok { 
      match => [ "message", "(?<bro.ts>(.*?))\t(?<bro.node>(.*?))\t(?<bro.filter>(.*?))\t(?<bro.init>(.*?))\t(?<bro.success>(.*))" ]
    }
  }

# BRO_dnslog ######################
  if [type] == "BRO_dnslog" {
    grok {
      match => [ "message", "(?<bro.ts>(.*?))\t(?<bro.uid>(.*?))\t(?<bro.id.orig_h>(.*?))\t(?<bro.id.orig_p>(.*?))\t(?<bro.id.resp_h>(.*?))\t(?<bro.id.resp_p>(.*?))\t(?<bro.proto>(.*?))\t(?<bro.trans_id>(.*?))\t(?<bro.query>(.*?))\t(?<bro.qclass>(.*?))\t(?<bro.qclass_name>(.*?))\t(?<bro.qtype>(.*?))\t(?<bro.qtype_name>(.*?))\t(?<bro.rcode>(.*?))\t(?<bro.rcode_name>(.*?))\t(?<bro.AA>(.*?))\t(?<bro.TC>(.*?))\t(?<bro.RD>(.*?))\t(?<bro.RA>(.*?))\t(?<bro.Z>(.*?))\t(?<bro.answers>(.*?))\t(?<bro.TTLs>(.*?))\t(?<bro.rejected>(.*))" ]
    }
  }

# geoip
  if [bro.id.resp_h] {
    geoip {
      source => "bro.id.resp_h"
      target => "geoip"
      #database => "/opt/logstash/vendor/geoip/GeoLiteCity.dat"
      add_field => [ "[geoip][coordinates]", "%{[geoip][longitude]}" ]
      add_field => [ "[geoip][coordinates]", "%{[geoip][latitude]}"  ]
    }
    mutate {
      convert => [ "[geoip][coordinates]", "float" ]
    }
    if [bro.id.orig_h] {
      geoip {
        source => "bro.id.orig_h"
        target => "geoip"
        #database => "/opt/logstash/vendor/geoip/GeoLiteCity.dat"
        add_field => [ "[geoip][coordinates]", "%{[geoip][longitude]}" ]
        add_field => [ "[geoip][coordinates]", "%{[geoip][latitude]}"  ]
      }
      mutate {
        convert => [ "[geoip][coordinates]", "float" ]
      }
    }
  }
 }
}

output {
  elasticsearch {
    host => localhost
  }
}

